/*
CLICK-PASS-API

API for managing payments and fiscalization with CLICK Pass.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package clickapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type PaymentAPI interface {

	/*
	CheckPaymentStatus Payment status check

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serviceId
	@param paymentId
	@return PaymentAPICheckPaymentStatusRequest
	*/
	CheckPaymentStatus(ctx context.Context, serviceId int64, paymentId int64) PaymentAPICheckPaymentStatusRequest

	// CheckPaymentStatusExecute executes the request
	//  @return PaymentStatusResponse
	CheckPaymentStatusExecute(r PaymentAPICheckPaymentStatusRequest) (*PaymentStatusResponse, *http.Response, error)

	/*
	CheckPaymentStatusByMTI Payment status check by merchant_trans_id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serviceId
	@param merchantTransId
	@return PaymentAPICheckPaymentStatusByMTIRequest
	*/
	CheckPaymentStatusByMTI(ctx context.Context, serviceId int64, merchantTransId string) PaymentAPICheckPaymentStatusByMTIRequest

	// CheckPaymentStatusByMTIExecute executes the request
	//  @return PaymentStatusByMTIResponse
	CheckPaymentStatusByMTIExecute(r PaymentAPICheckPaymentStatusByMTIRequest) (*PaymentStatusByMTIResponse, *http.Response, error)

	/*
	ConfirmPayment Payment confirmation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PaymentAPIConfirmPaymentRequest
	*/
	ConfirmPayment(ctx context.Context) PaymentAPIConfirmPaymentRequest

	// ConfirmPaymentExecute executes the request
	//  @return PaymentConfirmationResponse
	ConfirmPaymentExecute(r PaymentAPIConfirmPaymentRequest) (*PaymentConfirmationResponse, *http.Response, error)

	/*
	CreatePaymentWithClickPass Payment with CLICK Pass

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PaymentAPICreatePaymentWithClickPassRequest
	*/
	CreatePaymentWithClickPass(ctx context.Context) PaymentAPICreatePaymentWithClickPassRequest

	// CreatePaymentWithClickPassExecute executes the request
	//  @return ClickPassPaymentResponse
	CreatePaymentWithClickPassExecute(r PaymentAPICreatePaymentWithClickPassRequest) (*ClickPassPaymentResponse, *http.Response, error)

	/*
	DisableConfirmationMode Disable confirmation mode

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serviceId
	@return PaymentAPIDisableConfirmationModeRequest
	*/
	DisableConfirmationMode(ctx context.Context, serviceId int64) PaymentAPIDisableConfirmationModeRequest

	// DisableConfirmationModeExecute executes the request
	//  @return ConfirmationModeResponse
	DisableConfirmationModeExecute(r PaymentAPIDisableConfirmationModeRequest) (*ConfirmationModeResponse, *http.Response, error)

	/*
	EnableConfirmationMode Enable confirmation mode

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serviceId
	@return PaymentAPIEnableConfirmationModeRequest
	*/
	EnableConfirmationMode(ctx context.Context, serviceId int64) PaymentAPIEnableConfirmationModeRequest

	// EnableConfirmationModeExecute executes the request
	//  @return ConfirmationModeResponse
	EnableConfirmationModeExecute(r PaymentAPIEnableConfirmationModeRequest) (*ConfirmationModeResponse, *http.Response, error)

	/*
	PartialRefund Partial refund

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serviceId
	@param paymentId
	@param amount
	@return PaymentAPIPartialRefundRequest
	*/
	PartialRefund(ctx context.Context, serviceId int64, paymentId int64, amount float32) PaymentAPIPartialRefundRequest

	// PartialRefundExecute executes the request
	//  @return PartialRefundResponse
	PartialRefundExecute(r PaymentAPIPartialRefundRequest) (*PartialRefundResponse, *http.Response, error)

	/*
	PaymentWithToken Payment with token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PaymentAPIPaymentWithTokenRequest
	*/
	PaymentWithToken(ctx context.Context) PaymentAPIPaymentWithTokenRequest

	// PaymentWithTokenExecute executes the request
	//  @return TokenPaymentResponse
	PaymentWithTokenExecute(r PaymentAPIPaymentWithTokenRequest) (*TokenPaymentResponse, *http.Response, error)

	/*
	ReversePayment Payment reversal (cancel)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param serviceId
	@param paymentId
	@return PaymentAPIReversePaymentRequest
	*/
	ReversePayment(ctx context.Context, serviceId int64, paymentId int64) PaymentAPIReversePaymentRequest

	// ReversePaymentExecute executes the request
	//  @return PaymentReversalResponse
	ReversePaymentExecute(r PaymentAPIReversePaymentRequest) (*PaymentReversalResponse, *http.Response, error)
}

// PaymentAPIService PaymentAPI service
type PaymentAPIService service

type PaymentAPICheckPaymentStatusRequest struct {
	ctx context.Context
	ApiService PaymentAPI
	serviceId int64
	paymentId int64
	auth *string
}

func (r PaymentAPICheckPaymentStatusRequest) Auth(auth string) PaymentAPICheckPaymentStatusRequest {
	r.auth = &auth
	return r
}

func (r PaymentAPICheckPaymentStatusRequest) Execute() (*PaymentStatusResponse, *http.Response, error) {
	return r.ApiService.CheckPaymentStatusExecute(r)
}

/*
CheckPaymentStatus Payment status check

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param paymentId
 @return PaymentAPICheckPaymentStatusRequest
*/
func (a *PaymentAPIService) CheckPaymentStatus(ctx context.Context, serviceId int64, paymentId int64) PaymentAPICheckPaymentStatusRequest {
	return PaymentAPICheckPaymentStatusRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		paymentId: paymentId,
	}
}

// Execute executes the request
//  @return PaymentStatusResponse
func (a *PaymentAPIService) CheckPaymentStatusExecute(r PaymentAPICheckPaymentStatusRequest) (*PaymentStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.CheckPaymentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/merchant/payment/status/{service_id}/{payment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterValueToString(r.serviceId, "serviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"payment_id"+"}", url.PathEscape(parameterValueToString(r.paymentId, "paymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auth == nil {
		return localVarReturnValue, nil, reportError("auth is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Auth", r.auth, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentAPICheckPaymentStatusByMTIRequest struct {
	ctx context.Context
	ApiService PaymentAPI
	serviceId int64
	merchantTransId string
	auth *string
}

func (r PaymentAPICheckPaymentStatusByMTIRequest) Auth(auth string) PaymentAPICheckPaymentStatusByMTIRequest {
	r.auth = &auth
	return r
}

func (r PaymentAPICheckPaymentStatusByMTIRequest) Execute() (*PaymentStatusByMTIResponse, *http.Response, error) {
	return r.ApiService.CheckPaymentStatusByMTIExecute(r)
}

/*
CheckPaymentStatusByMTI Payment status check by merchant_trans_id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param merchantTransId
 @return PaymentAPICheckPaymentStatusByMTIRequest
*/
func (a *PaymentAPIService) CheckPaymentStatusByMTI(ctx context.Context, serviceId int64, merchantTransId string) PaymentAPICheckPaymentStatusByMTIRequest {
	return PaymentAPICheckPaymentStatusByMTIRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		merchantTransId: merchantTransId,
	}
}

// Execute executes the request
//  @return PaymentStatusByMTIResponse
func (a *PaymentAPIService) CheckPaymentStatusByMTIExecute(r PaymentAPICheckPaymentStatusByMTIRequest) (*PaymentStatusByMTIResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentStatusByMTIResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.CheckPaymentStatusByMTI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/merchant/payment/status_by_mti/{service_id}/{merchant_trans_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterValueToString(r.serviceId, "serviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merchant_trans_id"+"}", url.PathEscape(parameterValueToString(r.merchantTransId, "merchantTransId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auth == nil {
		return localVarReturnValue, nil, reportError("auth is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Auth", r.auth, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentAPIConfirmPaymentRequest struct {
	ctx context.Context
	ApiService PaymentAPI
	auth *string
	paymentConfirmationRequest *PaymentConfirmationRequest
}

func (r PaymentAPIConfirmPaymentRequest) Auth(auth string) PaymentAPIConfirmPaymentRequest {
	r.auth = &auth
	return r
}

func (r PaymentAPIConfirmPaymentRequest) PaymentConfirmationRequest(paymentConfirmationRequest PaymentConfirmationRequest) PaymentAPIConfirmPaymentRequest {
	r.paymentConfirmationRequest = &paymentConfirmationRequest
	return r
}

func (r PaymentAPIConfirmPaymentRequest) Execute() (*PaymentConfirmationResponse, *http.Response, error) {
	return r.ApiService.ConfirmPaymentExecute(r)
}

/*
ConfirmPayment Payment confirmation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentAPIConfirmPaymentRequest
*/
func (a *PaymentAPIService) ConfirmPayment(ctx context.Context) PaymentAPIConfirmPaymentRequest {
	return PaymentAPIConfirmPaymentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentConfirmationResponse
func (a *PaymentAPIService) ConfirmPaymentExecute(r PaymentAPIConfirmPaymentRequest) (*PaymentConfirmationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentConfirmationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.ConfirmPayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/merchant/click_pass/confirm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auth == nil {
		return localVarReturnValue, nil, reportError("auth is required and must be specified")
	}
	if r.paymentConfirmationRequest == nil {
		return localVarReturnValue, nil, reportError("paymentConfirmationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Auth", r.auth, "simple", "")
	// body params
	localVarPostBody = r.paymentConfirmationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentAPICreatePaymentWithClickPassRequest struct {
	ctx context.Context
	ApiService PaymentAPI
	auth *string
	clickPassPaymentRequest *ClickPassPaymentRequest
}

func (r PaymentAPICreatePaymentWithClickPassRequest) Auth(auth string) PaymentAPICreatePaymentWithClickPassRequest {
	r.auth = &auth
	return r
}

func (r PaymentAPICreatePaymentWithClickPassRequest) ClickPassPaymentRequest(clickPassPaymentRequest ClickPassPaymentRequest) PaymentAPICreatePaymentWithClickPassRequest {
	r.clickPassPaymentRequest = &clickPassPaymentRequest
	return r
}

func (r PaymentAPICreatePaymentWithClickPassRequest) Execute() (*ClickPassPaymentResponse, *http.Response, error) {
	return r.ApiService.CreatePaymentWithClickPassExecute(r)
}

/*
CreatePaymentWithClickPass Payment with CLICK Pass

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentAPICreatePaymentWithClickPassRequest
*/
func (a *PaymentAPIService) CreatePaymentWithClickPass(ctx context.Context) PaymentAPICreatePaymentWithClickPassRequest {
	return PaymentAPICreatePaymentWithClickPassRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ClickPassPaymentResponse
func (a *PaymentAPIService) CreatePaymentWithClickPassExecute(r PaymentAPICreatePaymentWithClickPassRequest) (*ClickPassPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClickPassPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.CreatePaymentWithClickPass")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/merchant/click_pass/payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auth == nil {
		return localVarReturnValue, nil, reportError("auth is required and must be specified")
	}
	if r.clickPassPaymentRequest == nil {
		return localVarReturnValue, nil, reportError("clickPassPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Auth", r.auth, "simple", "")
	// body params
	localVarPostBody = r.clickPassPaymentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentAPIDisableConfirmationModeRequest struct {
	ctx context.Context
	ApiService PaymentAPI
	serviceId int64
	auth *string
}

func (r PaymentAPIDisableConfirmationModeRequest) Auth(auth string) PaymentAPIDisableConfirmationModeRequest {
	r.auth = &auth
	return r
}

func (r PaymentAPIDisableConfirmationModeRequest) Execute() (*ConfirmationModeResponse, *http.Response, error) {
	return r.ApiService.DisableConfirmationModeExecute(r)
}

/*
DisableConfirmationMode Disable confirmation mode

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return PaymentAPIDisableConfirmationModeRequest
*/
func (a *PaymentAPIService) DisableConfirmationMode(ctx context.Context, serviceId int64) PaymentAPIDisableConfirmationModeRequest {
	return PaymentAPIDisableConfirmationModeRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return ConfirmationModeResponse
func (a *PaymentAPIService) DisableConfirmationModeExecute(r PaymentAPIDisableConfirmationModeRequest) (*ConfirmationModeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfirmationModeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.DisableConfirmationMode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/merchant/click_pass/confirmation/{service_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterValueToString(r.serviceId, "serviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auth == nil {
		return localVarReturnValue, nil, reportError("auth is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Auth", r.auth, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentAPIEnableConfirmationModeRequest struct {
	ctx context.Context
	ApiService PaymentAPI
	serviceId int64
	auth *string
}

func (r PaymentAPIEnableConfirmationModeRequest) Auth(auth string) PaymentAPIEnableConfirmationModeRequest {
	r.auth = &auth
	return r
}

func (r PaymentAPIEnableConfirmationModeRequest) Execute() (*ConfirmationModeResponse, *http.Response, error) {
	return r.ApiService.EnableConfirmationModeExecute(r)
}

/*
EnableConfirmationMode Enable confirmation mode

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @return PaymentAPIEnableConfirmationModeRequest
*/
func (a *PaymentAPIService) EnableConfirmationMode(ctx context.Context, serviceId int64) PaymentAPIEnableConfirmationModeRequest {
	return PaymentAPIEnableConfirmationModeRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
	}
}

// Execute executes the request
//  @return ConfirmationModeResponse
func (a *PaymentAPIService) EnableConfirmationModeExecute(r PaymentAPIEnableConfirmationModeRequest) (*ConfirmationModeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfirmationModeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.EnableConfirmationMode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/merchant/click_pass/confirmation/{service_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterValueToString(r.serviceId, "serviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auth == nil {
		return localVarReturnValue, nil, reportError("auth is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Auth", r.auth, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentAPIPartialRefundRequest struct {
	ctx context.Context
	ApiService PaymentAPI
	serviceId int64
	paymentId int64
	amount float32
	auth *string
}

func (r PaymentAPIPartialRefundRequest) Auth(auth string) PaymentAPIPartialRefundRequest {
	r.auth = &auth
	return r
}

func (r PaymentAPIPartialRefundRequest) Execute() (*PartialRefundResponse, *http.Response, error) {
	return r.ApiService.PartialRefundExecute(r)
}

/*
PartialRefund Partial refund

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param paymentId
 @param amount
 @return PaymentAPIPartialRefundRequest
*/
func (a *PaymentAPIService) PartialRefund(ctx context.Context, serviceId int64, paymentId int64, amount float32) PaymentAPIPartialRefundRequest {
	return PaymentAPIPartialRefundRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		paymentId: paymentId,
		amount: amount,
	}
}

// Execute executes the request
//  @return PartialRefundResponse
func (a *PaymentAPIService) PartialRefundExecute(r PaymentAPIPartialRefundRequest) (*PartialRefundResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PartialRefundResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PartialRefund")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/merchant/payment/partial_reversal/{service_id}/{payment_id}/{amount}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterValueToString(r.serviceId, "serviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"payment_id"+"}", url.PathEscape(parameterValueToString(r.paymentId, "paymentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"amount"+"}", url.PathEscape(parameterValueToString(r.amount, "amount")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auth == nil {
		return localVarReturnValue, nil, reportError("auth is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Auth", r.auth, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentAPIPaymentWithTokenRequest struct {
	ctx context.Context
	ApiService PaymentAPI
	auth *string
	tokenPaymentRequest *TokenPaymentRequest
}

func (r PaymentAPIPaymentWithTokenRequest) Auth(auth string) PaymentAPIPaymentWithTokenRequest {
	r.auth = &auth
	return r
}

func (r PaymentAPIPaymentWithTokenRequest) TokenPaymentRequest(tokenPaymentRequest TokenPaymentRequest) PaymentAPIPaymentWithTokenRequest {
	r.tokenPaymentRequest = &tokenPaymentRequest
	return r
}

func (r PaymentAPIPaymentWithTokenRequest) Execute() (*TokenPaymentResponse, *http.Response, error) {
	return r.ApiService.PaymentWithTokenExecute(r)
}

/*
PaymentWithToken Payment with token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentAPIPaymentWithTokenRequest
*/
func (a *PaymentAPIService) PaymentWithToken(ctx context.Context) PaymentAPIPaymentWithTokenRequest {
	return PaymentAPIPaymentWithTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TokenPaymentResponse
func (a *PaymentAPIService) PaymentWithTokenExecute(r PaymentAPIPaymentWithTokenRequest) (*TokenPaymentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TokenPaymentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.PaymentWithToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/merchant/card_token/payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auth == nil {
		return localVarReturnValue, nil, reportError("auth is required and must be specified")
	}
	if r.tokenPaymentRequest == nil {
		return localVarReturnValue, nil, reportError("tokenPaymentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Auth", r.auth, "simple", "")
	// body params
	localVarPostBody = r.tokenPaymentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentAPIReversePaymentRequest struct {
	ctx context.Context
	ApiService PaymentAPI
	serviceId int64
	paymentId int64
	auth *string
}

func (r PaymentAPIReversePaymentRequest) Auth(auth string) PaymentAPIReversePaymentRequest {
	r.auth = &auth
	return r
}

func (r PaymentAPIReversePaymentRequest) Execute() (*PaymentReversalResponse, *http.Response, error) {
	return r.ApiService.ReversePaymentExecute(r)
}

/*
ReversePayment Payment reversal (cancel)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceId
 @param paymentId
 @return PaymentAPIReversePaymentRequest
*/
func (a *PaymentAPIService) ReversePayment(ctx context.Context, serviceId int64, paymentId int64) PaymentAPIReversePaymentRequest {
	return PaymentAPIReversePaymentRequest{
		ApiService: a,
		ctx: ctx,
		serviceId: serviceId,
		paymentId: paymentId,
	}
}

// Execute executes the request
//  @return PaymentReversalResponse
func (a *PaymentAPIService) ReversePaymentExecute(r PaymentAPIReversePaymentRequest) (*PaymentReversalResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentReversalResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentAPIService.ReversePayment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/merchant/payment/reversal/{service_id}/{payment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"service_id"+"}", url.PathEscape(parameterValueToString(r.serviceId, "serviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"payment_id"+"}", url.PathEscape(parameterValueToString(r.paymentId, "paymentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.auth == nil {
		return localVarReturnValue, nil, reportError("auth is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Auth", r.auth, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
